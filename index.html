<html>
<head>
<base href="https://boccettetrainingtable.netlify.app/">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Boccette & Matamà</title>
<link href="https://fonts.googleapis.com/css2?family=Italianno&display=swap" rel="stylesheet">
<style>
body {
    margin: 0;
    padding: 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    background-color: #2c3e50;
    font-family: Arial, sans-serif;
    color: #ecf0f1;
    margin: 0;
    padding: 0;
}

#game-container {
    position: relative;
    margin: 20px;
}

#pool-table {
    background-color: #27ae60;
    border: 20px solid #8b4513;
    box-shadow: 0 0 20px rgba(0,0,0,0.5);
}

.diamond {
    position: absolute;
    width: 10px;
    height: 10px;
    background-color: #ecf0f1;
    transform: rotate(45deg);
}

#instructions {
    text-align: center;
    margin-top: 10px;
    margin-bottom: 20px;
    font-size: 14px;
    color: #ecf0f1;
}

#watermark {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    font-size: 72px;
    font-family: 'Italianno', cursive;
    color: rgba(255, 255, 255, 0.1);
    pointer-events: none;
    white-space: nowrap;
}

#credits {
    margin-top: 10px;
    margin-bottom: 10px;
    font-size: 14px;
    text-align: center;
}

#controls {
    margin-top: 20px;
    margin-bottom: 10px;
    padding-top: 5px;
    border-top: 0px solid #ecf0f1;
}

#controls input {
    margin: 0 10px;
    padding: 5px;
}

#controls button {
    padding: 5px 10px;
    background-color: #3498db;
    color: white;
    border: none;
    cursor: pointer;
}

#controls button:hover {
    background-color: #2980b9;
}

#message {
    position: absolute;
    top: 30%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 24px;
    color: red;
    background-color: rgba(255, 255, 255, 0.8);
    padding: 10px;
    border-radius: 5px;
    display: none;
}
#title {
    font-family: 'Italianno', cursive;
    font-size: 48px;
    color: #ffffff;
    text-align: center;
    margin-top: 10px;
    margin-bottom: 3px;
}
</style>
</head>
<body>
<h1 id="title">Boccette & Matamà</h1>
<div id="controls">
    <label for="tableWidth">Larghezza (cm):</label>
    <input type="number" id="tableWidth" value="277.0" min="100" max="500" step="0.1">
    <label for="tableLength">Lunghezza (cm):</label>
    <input type="number" id="tableLength" value="138.5" min="100" max="500" step="0.1">
    <label for="friction">Coefficiente di scorrimento (0-1):</label>
    <input type="number" id="friction" value="0.99" min="0.8" max="0.999" step="0.001">
    <label for="showGhost">Mostra traiettoria:</label>
    <input type="checkbox" id="showGhost">
    <button onclick="updateTable()">Aggiorna</button>
</div>

<div id="instructions">
    Clicca per posizionare la palla rossa, poi la bianca, infine sposta il mouse per definire direzione e forza
</div>

<div id="game-container">
    <div id="pool-table"></div>
    <div id="watermark">Boccette & Matamà</div>
    <div id="message"></div>
</div>

<div id="credits">Developed by molder, for boccettari friends, in honor of Nino Agliolo.</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
<script>
let TABLE_WIDTH = 1108; // 277cm * 4px/cm
let TABLE_HEIGHT = 554; // 138.5cm * 4px/cm
const BALL_DIAMETER = 23.2; // 58mm * 4px/cm * 0.1cm/mm
let FRICTION = 0.99;
const RESTITUTION = 0.8;

let whiteBall, redBall;
let startX, startY;
let isDragging = false;
let canvas;
let ghostPath = [];
let showGhost = false;
let castle;
let message;
let ballPath = [];
let placingRedBall = true;

function setup() {
    updateTable();
    message = document.getElementById('message');
}

function updateTable() {
    TABLE_WIDTH = document.getElementById('tableWidth').value * 4;
    TABLE_HEIGHT = document.getElementById('tableLength').value * 4;
    FRICTION = parseFloat(document.getElementById('friction').value);
    showGhost = document.getElementById('showGhost').checked;

    if (canvas) {
        canvas.remove();
    }
    canvas = createCanvas(TABLE_WIDTH, TABLE_HEIGHT);
    canvas.parent('pool-table');
    canvas.mousePressed(canvasMousePressed);
    
    document.getElementById('game-container').style.width = TABLE_WIDTH + 40 + 'px';
    document.getElementById('game-container').style.height = TABLE_HEIGHT + 40 + 'px';
    
    whiteBall = new Ball(width / 3, height / 3, BALL_DIAMETER, 'white');
    redBall = new Ball(2 * width / 3, height / 3, BALL_DIAMETER, 'red');
    castle = new Castle(width / 2, height / 2);
    createDiamonds();
    updateWatermarkPosition();
    ballPath = [];
    placingRedBall = true;
}

function updateWatermarkPosition() {
    const watermark = document.getElementById('watermark');
    watermark.style.top = (TABLE_HEIGHT * 0.75) + 'px';
}

function draw() {
    background('#27ae60');
    castle.display();
    
    if (showGhost && ballPath.length > 0) {
        noFill();
        stroke(255, 100);
        beginShape();
        for (let point of ballPath) {
            vertex(point.x, point.y);
        }
        endShape();
    }
    
    const SUBSTEPS = 5;
    for (let i = 0; i < SUBSTEPS; i++) {
        whiteBall.update();
        redBall.update();
        checkCollision(whiteBall, redBall);
        
        // Controllo collisione con il castello per ogni substep
        if (castle.checkCollision(whiteBall)) {
            showMessage("Hai bevuto! Niente matamà per te");
            whiteBall.vx *= -RESTITUTION;
            whiteBall.vy *= -RESTITUTION;
        }
        if (castle.checkCollision(redBall)) {
            showMessage("Bel colpo!");
            redBall.vx *= -RESTITUTION;
            redBall.vy *= -RESTITUTION;
        }
    }

    whiteBall.display();
    redBall.display();

    if (isDragging) {
        stroke(255);
        line(startX, startY, mouseX, mouseY);
        if (showGhost) {
            drawGhostPath();
        }
    }

    // Aggiornamento del percorso della pallina bianca
    if (abs(whiteBall.vx) > 0.01 || abs(whiteBall.vy) > 0.01) {
        ballPath.push({x: whiteBall.x, y: whiteBall.y});
    } else {
        // Resetta il percorso quando la pallina si ferma
        ballPath = [];
    }

    // Limita la lunghezza del percorso per evitare problemi di prestazioni
    if (ballPath.length > 1000) {
        ballPath.splice(0, ballPath.length - 1000);
    }
}

function canvasMousePressed() {
    if (placingRedBall) {
        redBall.x = mouseX;
        redBall.y = mouseY;
        redBall.vx = 0;
        redBall.vy = 0;
        placingRedBall = false;
    } else if (!isDragging) {
        startX = mouseX;
        startY = mouseY;
        whiteBall.x = startX;
        whiteBall.y = startY;
        whiteBall.vx = 0;
        whiteBall.vy = 0;
        isDragging = true;
        ghostPath = [];
        ballPath = [];
    } else {
        let force = dist(startX, startY, mouseX, mouseY) / 10;
        let angle = atan2(mouseY - startY, mouseX - startX);
        whiteBall.applyForce(force * cos(angle), force * sin(angle));
        isDragging = false;
        placingRedBall = true;
    }
}

function createDiamonds() {
    const gameContainer = document.getElementById('game-container');
    const existingDiamonds = gameContainer.querySelectorAll('.diamond');
    existingDiamonds.forEach(diamond => diamond.remove());

    const diamondPositions = [
        ...Array(9).fill().map((_, i) => ({x: i/8, y: 0})),
        ...Array(9).fill().map((_, i) => ({x: i/8, y: 1})),
        ...Array(5).fill().map((_, i) => ({x: 0, y: i/4})),
        ...Array(5).fill().map((_, i) => ({x: 1, y: i/4}))
    ];

    diamondPositions.forEach(pos => {
        let diamond = createDiv('');
        diamond.addClass('diamond');
        diamond.position(pos.x * TABLE_WIDTH + 15, pos.y * TABLE_HEIGHT + 15);
        diamond.parent('game-container');
    });
}

function drawGhostPath() {
    let ghostBall = new Ball(startX, startY, BALL_DIAMETER, 'white');
    let force = dist(startX, startY, mouseX, mouseY) / 10;
    let angle = atan2(mouseY - startY, mouseX - startX);
    ghostBall.applyForce(force * cos(angle), force * sin(angle));

    ghostPath = [];
    while (abs(ghostBall.vx) > 0.01 || abs(ghostBall.vy) > 0.01) {
        ghostBall.update();
        ghostPath.push({x: ghostBall.x, y: ghostBall.y});
    }

    noFill();
    stroke(255, 100);
    beginShape();
    for (let point of ghostPath) {
        vertex(point.x, point.y);
    }
    endShape();
}

function showMessage(text) {
    message.textContent = text;
    message.style.display = 'block';
    setTimeout(() => {
        message.style.display = 'none';
    }, 2000);
}

class Ball {
    constructor(x, y, diameter, color) {
        this.x = x;
        this.y = y;
        this.diameter = diameter;
        this.radius = diameter / 2;
        this.vx = 0;
        this.vy = 0;
        this.color = color;
        this.mass = 1; // Aggiunto massa
    }

	update() {
		// Calcoliamo la nuova posizione
		let newX = this.x + this.vx;
		let newY = this.y + this.vy;

		// Controlliamo le collisioni con le pareti
		if (newX - this.radius < 0) {
			newX = this.radius;
			this.vx = Math.abs(this.vx) * RESTITUTION;
		} else if (newX + this.radius > width) {
			newX = width - this.radius;
			this.vx = -Math.abs(this.vx) * RESTITUTION;
		}

		if (newY - this.radius < 0) {
			newY = this.radius;
			this.vy = Math.abs(this.vy) * RESTITUTION;
		} else if (newY + this.radius > height) {
			newY = height - this.radius;
			this.vy = -Math.abs(this.vy) * RESTITUTION;
		}

		// Aggiorniamo la posizione
		this.x = newX;
		this.y = newY;

		// Applichiamo l'attrito
		this.vx *= FRICTION;
		this.vy *= FRICTION;

		// Fermiamo la pallina se la velocità è molto bassa
		if (Math.abs(this.vx) < 0.01 && Math.abs(this.vy) < 0.01) {
			this.vx = 0;
			this.vy = 0;
		}
	}
}

class Castle {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.pinRadius = 2; // 4mm * 4px/cm * 0.1cm/mm
        this.distance = 24; // 60mm * 4px/cm * 0.1cm/mm
    }

    display() {
        fill(255, 0, 0); // Red for central pin
        ellipse(this.x, this.y, this.pinRadius * 2); // Central red pin
        fill(255); // White for lateral pins
        ellipse(this.x - this.distance, this.y, this.pinRadius * 2);
        ellipse(this.x + this.distance, this.y, this.pinRadius * 2);
        ellipse(this.x, this.y - this.distance, this.pinRadius * 2);
        ellipse(this.x, this.y + this.distance, this.pinRadius * 2);
    }

    checkCollision(ball) {
        let pins = [
            {x: this.x, y: this.y},
            {x: this.x - this.distance, y: this.y},
            {x: this.x + this.distance, y: this.y},
            {x: this.x, y: this.y - this.distance},
            {x: this.x, y: this.y + this.distance}
        ];

        for (let pin of pins) {
            let d = dist(ball.x, ball.y, pin.x, pin.y);
            if (d < ball.radius + this.pinRadius) {
                return true;
            }
        }
        return false;
    }
}

function checkCollision(ball1, ball2) {
    let dx = ball2.x - ball1.x;
    let dy = ball2.y - ball1.y;
    let distanceSquared = dx * dx + dy * dy;
    let minDistance = ball1.radius + ball2.radius;

    if (distanceSquared < minDistance * minDistance) {
        let distance = Math.sqrt(distanceSquared);
        let nx = dx / distance;
        let ny = dy / distance;

        // Calcolare la velocità relativa
        let dvx = ball2.vx - ball1.vx;
        let dvy = ball2.vy - ball1.vy;
        let dotProduct = dvx * nx + dvy * ny;

        // Se le palline si stanno allontanando, non facciamo nulla
        if (dotProduct > 0) return;

        let impulse = -(1 + RESTITUTION) * dotProduct / 
                      (1 / ball1.mass + 1 / ball2.mass);

        ball1.vx -= impulse * nx / ball1.mass;
        ball1.vy -= impulse * ny / ball1.mass;
        ball2.vx += impulse * nx / ball2.mass;
        ball2.vy += impulse * ny / ball2.mass;

        // Separiamo le palline
        let correction = (minDistance - distance) / 2;
        ball1.x -= nx * correction;
        ball1.y -= ny * correction;
        ball2.x += nx * correction;
        ball2.y += ny * correction;
    }
}

</script>
</body>
</html>
